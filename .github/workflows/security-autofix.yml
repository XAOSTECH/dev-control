name: Security Auto-Fix Bot

on:
  # Trigger on CodeQL scan completion
  workflow_run:
    workflows: ["CodeQL Advanced Security"]
    types:
      - completed
  
  # Manual trigger for testing
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  security-events: read

jobs:
  autofix:
    name: Auto-fix Security Alerts
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run && github.event.workflow_run.conclusion == 'success') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate security app token
        id: app_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.XSS_AI }}
          private-key: ${{ secrets.XSS_PK }}
          permission-actions: read
          permission-security-events: read
          permission-workflows: write
          permission-contents: write
          permission-pull-requests: write

      - name: Fetch and analyze CodeQL alerts
        id: alerts
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          # Fetch open security alerts
          ALERTS=$(gh api repos/${{ github.repository }}/code-scanning/alerts?state=open \
            --jq '[.[] | select(.rule.severity == "error" or .rule.severity == "warning") | {
              number: .number,
              rule: .rule.id,
              severity: .rule.severity,
              file: .most_recent_instance.location.path,
              line: .most_recent_instance.location.start_line,
              message: .most_recent_instance.message.text
            }]')
          
          echo "Found $(echo "$ALERTS" | jq 'length') open alerts"
          
          # Count fixable and unfixable alerts
          FIXABLE_COUNT=$(echo "$ALERTS" | jq '[.[] | select(.rule == "actions/code-injection/medium" or .rule == "actions/unpinned-tag")] | length')
          TOTAL_COUNT=$(echo "$ALERTS" | jq 'length')
          UNFIXABLE_COUNT=$((TOTAL_COUNT - FIXABLE_COUNT))
          
          echo "fixable_count=$FIXABLE_COUNT" >> "$GITHUB_OUTPUT"
          echo "unfixable_count=$UNFIXABLE_COUNT" >> "$GITHUB_OUTPUT"
          echo "$ALERTS" > /tmp/alerts.json
          
          if [ "$FIXABLE_COUNT" -eq 0 ]; then
            echo "No auto-fixable alerts found"
            exit 0
          fi

      - name: Apply automatic fixes
        if: steps.alerts.outputs.fixable_count > 0
        id: fixes
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          set -eu
          trap 'echo "Error on line $LINENO"; exit 1' ERR
          
          REPO="${{ github.repository }}"
          TOKEN="$GH_TOKEN"
          ALERTS_FILE="/tmp/alerts.json"
          
          FIXES_APPLIED=0
          
          echo "üîß Processing security alerts from $ALERTS_FILE..."
          
          if [[ ! -f "$ALERTS_FILE" ]]; then
            echo "‚ùå Alerts file not found: $ALERTS_FILE"
            exit 1
          fi
          
          ALERTS=$(cat "$ALERTS_FILE") || { echo "‚ùå Failed to read alerts file"; exit 1; }
          echo "Loaded alerts: $(echo "$ALERTS" | jq -r 'length') total"
          
          # Pattern 1: Fix code injection - Extract GitHub expressions to env vars
          echo "üîß Fixing code injection vulnerabilities..."
          
          CODE_INJECTION_ALERTS=$(echo "$ALERTS" | jq '[.[] | select(.rule == "actions/code-injection/medium")]' 2>/dev/null || echo "[]")
          CODE_INJECTION_COUNT=$(echo "$CODE_INJECTION_ALERTS" | jq 'length')
          echo "Found $CODE_INJECTION_COUNT code-injection alerts"
          
          # Group alerts by file to avoid duplicate env sections
          declare -A file_vars
          declare -A file_exprs
          
          echo "$CODE_INJECTION_ALERTS" | jq -c '.[]' | while IFS= read -r alert_json; do
            [[ -z "$alert_json" ]] && continue
            
            file=$(echo "$alert_json" | jq -r '.file // empty')
            msg=$(echo "$alert_json" | jq -r '.message // empty')
            rule=$(echo "$alert_json" | jq -r '.rule // empty')
            
            [[ -z "$file" ]] || [[ ! -f "$file" ]] && continue
            [[ "$rule" != "actions/code-injection/medium" ]] && continue
            [[ -z "$msg" ]] && continue
            
            if [[ "$msg" =~ \$\{\{\s*([^}]+)\s*\}\} ]]; then
              var_expr="${BASH_REMATCH[1]}"
              # Trim spaces from captured expression
              var_expr=$(echo "$var_expr" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              var_name="FIX_$(echo "$var_expr" | sed 's/[^a-zA-Z0-9_]/_/g' | tr '[:lower:]' '[:upper:]')"
              var_name="${var_name:0:32}"
              
              echo "  üìù Processing $file: $var_expr ‚Üí $var_name"
              
              # Replace expression with variable in file
              escaped_expr=$(printf '%s\n' "$var_expr" | sed 's/[&/\]/\\&/g' | sed 's/\[\|\]\|\.\|\*\|\^\|\$/\\&/g')
              sed -i "s/\${{ *$escaped_expr *}}/\$$var_name/g" "$file"
              
              # Store mapping for later env insertion (append to file's list)
              if [[ -z "${file_vars[$file]:-}" ]]; then
                file_vars[$file]="$var_name"
                file_exprs[$file]="$var_expr"
              else
                file_vars[$file]="${file_vars[$file]}|$var_name"
                file_exprs[$file]="${file_exprs[$file]}|$var_expr"
              fi
              
              FIXES_APPLIED=$((FIXES_APPLIED + 1))
            fi
          done
          
          # Now insert consolidated env sections per file
          for file in "${!file_vars[@]}"; do
            echo "  üîß Adding consolidated env section to $file"
            
            # Find the first run: line in the file that uses any of our variables
            IFS='|' read -ra VARNAMES <<< "${file_vars[$file]}"
            for var_name in "${VARNAMES[@]}"; do
              linenum=$(grep -n "\$$var_name" "$file" | head -1 | cut -d: -f1)
              if [[ -n "$linenum" ]]; then
                # Search backwards to find the run: line
                runline=$(awk -v target="$linenum" 'NR < target && /^        run:/ {last=NR} END {print last}' "$file")
                
                if [[ -n "$runline" ]]; then
                  # Build env section with ALL variables for this file
                  {
                    head -n $((runline - 1)) "$file"
                    echo "        env:"
                    IFS='|' read -ra VARNAMES <<< "${file_vars[$file]}"
                    IFS='|' read -ra EXPRS <<< "${file_exprs[$file]}"
                    for i in "${!VARNAMES[@]}"; do
                      echo "          ${VARNAMES[$i]}: \${{ ${EXPRS[$i]} }}"
                    done
                    tail -n +$runline "$file"
                  } > "$file.tmp" && mv "$file.tmp" "$file"
                  echo "  ‚úÖ Fixed $file with ${#VARNAMES[@]} variables"
                  break
                fi
              fi
            done
          done
          
          # Pattern 2: Fix unpinned actions
          echo "üîß Fixing unpinned actions..."
          
          echo "$ALERTS" | jq -c '.[] | select(.rule == "actions/unpinned-tag")' | while IFS= read -r alert_json; do
            file=$(echo "$alert_json" | jq -r '.file // empty')
            rule=$(echo "$alert_json" | jq -r '.rule // empty')
            
            [[ ! -f "$file" ]] && continue
            [[ "$rule" != "actions/unpinned-tag" ]] && continue
            
            while IFS= read -r line_content; do
              if [[ "$line_content" =~ uses:\ ([^@]+)@(master|main|v[0-9]+)($|\ ) ]]; then
                action="${BASH_REMATCH[1]}"
                ref="${BASH_REMATCH[2]}"
                
                [[ "$action" == ./* ]] && continue
                [[ "$action" != */* ]] && continue
                
                owner=$(echo "$action" | cut -d/ -f1)
                repo=$(echo "$action" | cut -d/ -f2-)
                
                sha=$(GH_TOKEN="$TOKEN" gh api "repos/$owner/$repo/commits/$ref" --jq '.sha' 2>/dev/null | head -c 40)
                
                if [[ -n "$sha" && "$sha" =~ ^[0-9a-f]{40}$ ]]; then
                  sed -i "s|uses: $action@$ref|uses: $action@$sha|g" "$file"
                  FIXES_APPLIED=$((FIXES_APPLIED + 1))
                  echo "  ‚úÖ Pinned $action@$ref ‚Üí $sha"
                fi
              fi
            done < "$file"
          done
          
          echo "‚úì Total fixes applied: $FIXES_APPLIED"
          git diff --name-only 2>/dev/null || true
          
          # Export modified files
          MODIFIED=$(git diff --name-only || true)
          echo "modified_files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$MODIFIED" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "fixes_applied=$(git diff --name-only | wc -l)" >> "$GITHUB_OUTPUT"

      - name: Create security fix PR
        if: steps.fixes.outputs.fixes_applied > 0 || steps.fixes.outputs.code_injection_found == 'true'
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          BRANCH="security/autofix-$(date +%s)"
          REPO="${{ github.repository }}"
          
          # Get the latest commit SHA from main
          MAIN_SHA=$(gh api "/repos/$REPO/git/ref/heads/main" --jq '.object.sha')
          echo "Main branch SHA: $MAIN_SHA"
          
          # Create blobs for modified files and build tree JSON using jq
          echo "Creating file blobs..."
          TREE_JSON="[]"

          if [[ -z "${{ steps.fixes.outputs.modified_files }}" ]]; then
            echo "No files were modified. Skipping PR creation."
            exit 0
          fi
          
          for file in $(echo "${{ steps.fixes.outputs.modified_files }}" | xargs -n1 | sort -u); do
            if [[ -f "$file" ]]; then
              echo "  üìù Processing $file"
              # Create blob via API
              BLOB_SHA=$(gh api "/repos/$REPO/git/blobs" \
                -X POST \
                -f content="$(cat "$file")" \
                -f encoding="utf-8" \
                --jq '.sha')
              
              # Add to tree array using jq for proper JSON construction
              TREE_JSON=$(echo "$TREE_JSON" | jq --arg path "$file" --arg sha "$BLOB_SHA" \
                '. += [{"path": $path, "mode": "100644", "type": "blob", "sha": $sha}]')
            fi
          done
          
          echo "Tree JSON built with $(echo "$TREE_JSON" | jq 'length') items"
          echo "Tree JSON sample: $(echo "$TREE_JSON" | jq '.[0]' 2>/dev/null || echo 'empty')"
          
          # Get the base tree SHA
          BASE_TREE=$(gh api "/repos/$REPO/git/commits/$MAIN_SHA" --jq '.tree.sha')
          echo "Base tree: $BASE_TREE"
          
          # Create new tree
          echo "Creating git tree..."
          # GitHub API expects: POST /repos/{owner}/{repo}/git/trees
          # Body: {base_tree: SHA, tree: [{path: string, mode: string, type: string, sha: string}]}
          TREE_PAYLOAD=$(jq -n --arg base_tree "$BASE_TREE" --argjson tree "$TREE_JSON" \
            '{base_tree: $base_tree, tree: $tree}')
          if ! TREE_SHA=$(printf '%s' "$TREE_PAYLOAD" | gh api "/repos/$REPO/git/trees" -X POST --input - --jq '.sha'); then
            echo "Tree creation failed. Debug info:"
            echo "BASE_TREE=$BASE_TREE"
            echo "TREE_JSON=$TREE_JSON"
            echo "TREE_PAYLOAD=$TREE_PAYLOAD"
            exit 1
          fi
          echo "New tree SHA: $TREE_SHA"
          
          # Create commit
          echo "Creating commit..."
          COMMIT_PAYLOAD=$(jq -n \
            --arg message "security: auto-fix CodeQL alerts" \
            --arg tree "$TREE_SHA" \
            --arg parent "$MAIN_SHA" \
            '{message: $message, tree: $tree, parents: [$parent]}')
          if ! COMMIT_SHA=$(printf '%s' "$COMMIT_PAYLOAD" | gh api "/repos/$REPO/git/commits" -X POST --input - --jq '.sha'); then
            echo "Commit creation failed. Debug info:"
            echo "COMMIT_PAYLOAD=$COMMIT_PAYLOAD"
            exit 1
          fi
          echo "Commit SHA: $COMMIT_SHA"
          
          # Create branch reference
          echo "Creating branch $BRANCH..."
          gh api "/repos/$REPO/git/refs" \
            -X POST \
            -f ref="refs/heads/$BRANCH" \
            -f sha="$COMMIT_SHA"
          
          # Create PR - write body to temp file
          echo "Automated Security Fixes" > /tmp/pr_body.md
          echo "========================" >> /tmp/pr_body.md
          echo "" >> /tmp/pr_body.md
          echo "This PR contains automatic fixes for security alerts detected by CodeQL." >> /tmp/pr_body.md
          echo "" >> /tmp/pr_body.md
          echo "Alerts Addressed:" >> /tmp/pr_body.md
          cat /tmp/alerts.json | jq -r '.[] | "- [\(.severity | ascii_upcase)] \(.rule): \(.file):\(.line)"' >> /tmp/pr_body.md
          echo "" >> /tmp/pr_body.md
          echo "Changes Made:" >> /tmp/pr_body.md
          echo "- Extract GitHub Actions context variables to environment variables" >> /tmp/pr_body.md
          echo "- Pin unpinned third-party actions to commit SHAs" >> /tmp/pr_body.md
          echo "- Quote shell variables to prevent code injection" >> /tmp/pr_body.md
          echo "" >> /tmp/pr_body.md
          echo "Verification Needed:" >> /tmp/pr_body.md
          echo "Review required - validate that fixes don't break workflow functionality" >> /tmp/pr_body.md
          echo "" >> /tmp/pr_body.md
          echo "---" >> /tmp/pr_body.md
          echo "Auto-generated by security-autofix workflow" >> /tmp/pr_body.md
          
          # Ensure labels exist before creating PR
          gh label create security --color D73A4A --description "Security-related changes" --force || true
          gh label create automated --color 0E8A16 --description "Automated changes" --force || true
          gh label create automerge --color 32BF6F --description "Auto-merge this PR" --force || true

          gh pr create \
            --repo "$REPO" \
            --base main \
            --head "$BRANCH" \
            --title "üîí Security Auto-Fix: CodeQL Alerts" \
            --body-file /tmp/pr_body.md \
            --label security,automated,automerge

      - name: Create GitHub Issue for manual review
        if: steps.alerts.outputs.unfixable_count > 0
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          # Check if a recent security-review issue exists and close it (we'll replace with updated alerts)
          RECENT_ISSUE=$(gh issue list --state open --label security-review --json number,createdAt --jq '.[] | select(.createdAt > (now - 3600)) | .number' 2>/dev/null | head -1)
          
          if [ -n "$RECENT_ISSUE" ]; then
            echo "‚ÑπÔ∏è  Closing recent security review issue #${RECENT_ISSUE} and replacing with updated alerts"
            gh issue close "$RECENT_ISSUE" --comment "Replaced with updated alert set from latest CodeQL scan"
          fi
          
          # Create tracking issue - write body to temp file
          echo "Security Alerts Requiring Manual Review" > /tmp/issue_body.md
          echo "=========================================" >> /tmp/issue_body.md
          echo "" >> /tmp/issue_body.md
          echo "The following CodeQL alerts cannot be automatically fixed and require manual intervention:" >> /tmp/issue_body.md
          echo "" >> /tmp/issue_body.md
          # Filter to only unfixable alerts (exclude code-injection/medium and unpinned-tag)
          jq -r '.[] | select(.rule != "actions/code-injection/medium" and .rule != "actions/unpinned-tag") | "### Alert #\(.number): \(.rule)\n- **Severity**: \(.severity)\n- **File**: `\(.file):\(.line)`\n- **Message**: \(.message)\n"' /tmp/alerts.json >> /tmp/issue_body.md
          echo "" >> /tmp/issue_body.md
          echo "### Recommended Actions" >> /tmp/issue_body.md
          echo "1. Review each alert in the [Security tab](https://github.com/${{ github.repository }}/security/code-scanning)" >> /tmp/issue_body.md
          echo "2. Apply fixes following GitHub Security Lab recommendations" >> /tmp/issue_body.md
          echo "3. Close alerts as fixed or false positive in dashboard" >> /tmp/issue_body.md
          echo "" >> /tmp/issue_body.md
          echo "---" >> /tmp/issue_body.md
          echo "Auto-generated by security-autofix workflow" >> /tmp/issue_body.md
          
          gh issue create \
            --title "üîí Security Review: CodeQL Alerts Require Manual Fixes" \
            --label security-review,help-wanted \
            --body-file /tmp/issue_body.md
