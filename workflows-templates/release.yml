# ============================================================================
# Release Workflow (release.yml)
# ============================================================================
#
# Automates GitHub releases for Dev-Control or any project using packaging.sh.
# Builds tarball, creates GitHub release, manages version and latest tags.
#
# TRIGGERS:
#   - Manual dispatch (recommended for controlled releases)
#   - Push to tags matching v* (requires careful tagging)
#   - Push to tags matching lib-v* (library-only release)
#
# RELEASE TYPES:
#   1. Full Release (v*): Complete dev-control with CLI, scripts, plugins
#   2. Library Release (lib-v*): Lightweight lib-only package (tui, print, colours)
#
# SAFEGUARDS:
#   âœ“ Version format validation (semantic versioning)
#   âœ“ Commit validation (minimum changes before release)
#   âœ“ Manual approval workflow support
#   âœ“ Tag existence checks to prevent overwrites
#   âœ“ CHANGELOG validation
#
# WHAT IT DOES:
#   1. Validates version format and commit count
#   2. Builds tarball using packaging.sh
#   3. Creates GitHub release with tarball attached
#   4. Updates 'latest' tag to point to new release
#   5. Generates release notes from commits
#   6. (Optional) Builds and releases lib-only package
#
# LIBRARY-ONLY RELEASE:
#   The lib release creates a lightweight package containing only:
#   - colors.sh, print.sh, tui.sh, output.sh, validation.sh, cli.sh, version.sh
#   
#   Use cases:
#   - Projects wanting TUI/print utilities without full toolkit
#   - Consistent terminal formatting without git/gh dependencies
#   
#   Trigger methods:
#   - Push tag: git tag -a lib-v1.0.0 -m "Lib release v1.0.0" && git push origin lib-v1.0.0
#   - Manual: Run workflow with include_lib=true (both releases)
#   - Manual: Run workflow with lib_only=true (lib only)
#
# RECOMMENDED WORKFLOW:
#
#   1. Create feature branch: git checkout -b feat/my-feature
#   2. Make changes and test locally: ./tests/run_tests.sh
#   3. Create PR and merge to main
#   4. Update CHANGELOG.md with version section
#   5. Commit changelog: git commit -m "chore: update CHANGELOG for v1.0.0"
#   6. Create tag: git tag -a v1.0.0 -m "Release v1.0.0"
#   7. Push tag: git push origin v1.0.0
#
# OR use manual dispatch for testing/special releases:
#   - Actions â†’ Release â†’ Run workflow â†’ Enter version
#
# BEST PRACTICES:
#   - Always update CHANGELOG.md before releasing
#   - Use semantic versioning (v1.0.0, not v1.0 or v01.00.00)
#   - Create annotated tags: git tag -a v1.0.0 -m "message"
#   - Wait for at least 3 commits since last release
#   - Run full test suite locally before tagging
#   - Review commits to ensure quality with: git log v0.9.0..main --oneline
#
# ============================================================================

name: Release

on:
  push:
    tags:
      - 'v*'
      - 'lib-v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0 without v prefix)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false
      draft:
        description: 'Create as draft release'
        required: false
        type: boolean
        default: false
      include_lib:
        description: 'Also release standalone lib package (dev-control-lib)'
        required: false
        type: boolean
        default: false
      lib_only:
        description: 'Release ONLY the lib package (skip main release)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

env:
  GUM_VERSION: '0.17.0'

jobs:
  release:
    runs-on: ubuntu-latest
    # Skip main release if lib_only is set
    if: ${{ github.event.inputs.lib_only != 'true' && !startsWith(github.ref, 'refs/tags/lib-') }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Extract version from tag (remove 'v' prefix)
            VERSION="${GITHUB_REF#refs/tags/v}"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          else
            # Manual dispatch - use input
            VERSION="${{ github.event.inputs.version }}"
            TAG_NAME="v${VERSION}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Release version: ${VERSION}"
          echo "ðŸ·ï¸ Tag: ${TAG_NAME}"

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected: X.Y.Z or X.Y.Z-suffix (e.g., 1.0.0, 2.1.0-beta)"
            exit 1
          fi
          echo "âœ… Version format valid: $VERSION"

      - name: Validate commit count
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Get previous tag (if any)
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [[ -n "$PREV_TAG" ]]; then
            COMMIT_COUNT=$(git log "${PREV_TAG}..HEAD" --oneline | wc -l)
            echo "ðŸ“Š Commits since ${PREV_TAG}: ${COMMIT_COUNT}"
            
            # Minimum 2 commits for release (1 for changelog, 1+ for actual changes)
            if [[ $COMMIT_COUNT -lt 2 ]]; then
              echo "âš ï¸ Warning: Only ${COMMIT_COUNT} commit(s) since last release"
              echo "â„¹ï¸ Consider waiting for more changes before releasing"
              echo "â„¹ï¸ Current practice: aim for 3+ commits per release"
              # Don't fail - allow manual override for hotfixes
            fi
            
            git log "${PREV_TAG}..HEAD" --oneline
          else
            echo "ðŸ“Š Initial release - no previous tags"
            COMMIT_COUNT=$(git log --oneline | wc -l)
            echo "ðŸ“Š Total commits in repository: ${COMMIT_COUNT}"
          fi

      - name: Validate CHANGELOG.md
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          if [[ ! -f "CHANGELOG.md" ]]; then
            echo "âš ï¸ Warning: CHANGELOG.md not found"
            echo "â„¹ï¸ Consider adding CHANGELOG.md for better release documentation"
          else
            # Check if version appears in CHANGELOG
            if grep -q "## \[${VERSION}\]" CHANGELOG.md 2>/dev/null || \
               grep -q "## ${VERSION}" CHANGELOG.md 2>/dev/null; then
              echo "âœ… CHANGELOG.md updated for version ${VERSION}"
              echo ""
              echo "ðŸ“ Changelog entry:"
              grep -A 20 "## \[${VERSION}\]" CHANGELOG.md 2>/dev/null || \
              grep -A 20 "## ${VERSION}" CHANGELOG.md
            else
              echo "âš ï¸ Warning: Version ${VERSION} not found in CHANGELOG.md"
              echo "â„¹ï¸ Consider adding a changelog entry for this release"
              echo ""
              echo "Expected format:"
              echo "## [${VERSION}] - $(date +%Y-%m-%d)"
              echo "### Added"
              echo "- Feature 1"
              echo "### Fixed"
              echo "- Fix 1"
            fi
          fi

      - name: Create tag (manual dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $TAG_NAME already exists, skipping tag creation"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            git push origin "$TAG_NAME"
            echo "âœ… Created and pushed tag: $TAG_NAME"
          fi

      - name: Update package version in config
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Update .dc-package.yaml if it exists
          if [[ -f ".dc-package.yaml" ]]; then
            sed -i "s/^version:.*/version: ${VERSION}/" .dc-package.yaml
            echo "âœ… Updated .dc-package.yaml to version ${VERSION}"
          fi
          
          # Create temporary config if none exists
          if [[ ! -f ".dc-package.yaml" ]]; then
            cat > .dc-package.yaml << EOF
          name: $(basename "$GITHUB_REPOSITORY")
          version: ${VERSION}
          description: "Version ${VERSION}"
          homepage: https://github.com/$GITHUB_REPOSITORY
          license: GPL-3.0-or-later
          entry_point: ./dc
          include:
            - scripts/
            - config/
            - docs/
            - plugins/
            - README.md
            - LICENSE
            - install.sh
          dependencies:
            - git
            - gh
            - jq
            - gum
          EOF
            echo "âœ… Created temporary .dc-package.yaml"
          fi

      - name: Install Gum
        run: |
          curl -fsSL "https://github.com/charmbracelet/gum/releases/download/v${GUM_VERSION}/gum_${GUM_VERSION}_Linux_x86_64.tar.gz" \
            | tar xz --strip-components=1 -C /tmp "gum_${GUM_VERSION}_Linux_x86_64/gum"
          sudo mv /tmp/gum /usr/local/bin/
          echo "âœ… Installed Gum v${GUM_VERSION}"

      - name: Build tarball
        run: |
          chmod +x scripts/packaging.sh scripts/lib/*.sh 2>/dev/null || true
          bash scripts/packaging.sh --tarball --verbose
          echo "âœ… Tarball built successfully"

      - name: List build artifacts
        run: |
          echo "ðŸ“¦ Build artifacts:"
          ls -la dist/
          
          # Get tarball path and checksum
          TARBALL=$(ls dist/*.tar.gz 2>/dev/null | head -1)
          if [[ -n "$TARBALL" ]]; then
            echo "tarball_path=${TARBALL}" >> $GITHUB_ENV
            echo "tarball_name=$(basename "$TARBALL")" >> $GITHUB_ENV
            
            if [[ -f "${TARBALL}.sha256" ]]; then
              SHA256=$(cat "${TARBALL}.sha256")
              echo "tarball_sha256=${SHA256}" >> $GITHUB_ENV
              echo "ðŸ” SHA256: ${SHA256}"
            fi
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          # Generate changelog
          NOTES_FILE=$(mktemp)
          
          cat > "$NOTES_FILE" << EOF
          ## What's Changed
          
          EOF
          
          if [[ -n "$PREV_TAG" ]]; then
            echo "### Commits since ${PREV_TAG}" >> "$NOTES_FILE"
            echo "" >> "$NOTES_FILE"
            git log "${PREV_TAG}..HEAD" --pretty=format:"- %s (%h)" >> "$NOTES_FILE"
          else
            echo "### Initial Release" >> "$NOTES_FILE"
            echo "" >> "$NOTES_FILE"
            git log --pretty=format:"- %s (%h)" -10 >> "$NOTES_FILE"
          fi
          
          cat >> "$NOTES_FILE" << EOF
          
          ## Installation
          
          ### Quick Install (tarball)
          \`\`\`bash
          curl -fsSL https://github.com/$GITHUB_REPOSITORY/releases/download/${TAG_NAME}/${tarball_name} | tar xz
          cd dev-control-${VERSION}
          ./install.sh
          \`\`\`
          
          ### Homebrew (coming soon)
          \`\`\`bash
          brew tap xaoscience/tap
          brew install dev-control
          \`\`\`
          
          ## Checksums
          
          | File | SHA256 |
          |------|--------|
          | ${tarball_name} | \`${tarball_sha256}\` |
          
          ---
          
          **Full Changelog**: https://github.com/$GITHUB_REPOSITORY/compare/${PREV_TAG}...${TAG_NAME}
          EOF
          
          # Output for next step
          echo "notes_file=${NOTES_FILE}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“ Release notes generated"
          cat "$NOTES_FILE"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag_name }}
          name: "Release ${{ steps.version.outputs.tag_name }}"
          body_path: ${{ steps.release_notes.outputs.notes_file }}
          draft: ${{ github.event.inputs.draft || false }}
          prerelease: ${{ github.event.inputs.prerelease || false }}
          files: |
            dist/*.tar.gz
            dist/*.sha256
          fail_on_unmatched_files: false
          generate_release_notes: false

      - name: Update 'latest' tag
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          # Delete existing 'latest' tag (local and remote)
          git tag -d latest 2>/dev/null || true
          git push origin :refs/tags/latest 2>/dev/null || true
          
          # Create new 'latest' tag pointing to this release
          git tag latest "$TAG_NAME"
          git push origin latest
          
          echo "âœ… Updated 'latest' tag to point to ${TAG_NAME}"

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          
          echo "## ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${VERSION} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | ${TAG_NAME} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tarball | ${tarball_name} |" >> $GITHUB_STEP_SUMMARY
          echo "| SHA256 | \`${tarball_sha256:0:16}...\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Release](https://github.com/$GITHUB_REPOSITORY/releases/tag/${TAG_NAME})" >> $GITHUB_STEP_SUMMARY
          echo "- [Download](https://github.com/$GITHUB_REPOSITORY/releases/download/${TAG_NAME}/${tarball_name})" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Library-Only Release Job
  # ============================================================================
  # Builds and releases a lightweight lib-only package containing just the
  # shared Bash utilities (colours, print, tui, validation, etc.) without
  # the full dev-control CLI, git integration, or plugins.
  #
  # TRIGGERS:
  #   - Push to tags matching lib-v* (e.g., lib-v0.2.0)
  #   - Manual dispatch with include_lib=true or lib_only=true
  #
  # USE CASE:
  #   Projects that want to use dev-control's TUI/print/colour libraries
  #   for consistent terminal output without the entire toolkit.
  # ============================================================================

  release-lib:
    runs-on: ubuntu-latest
    # Run when: lib-v* tag pushed, OR include_lib=true, OR lib_only=true
    if: |
      startsWith(github.ref, 'refs/tags/lib-v') ||
      github.event.inputs.include_lib == 'true' ||
      github.event.inputs.lib_only == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine lib version
        id: lib_version
        run: |
          if [[ "${{ github.event_name }}" == "push" && "$GITHUB_REF" == refs/tags/lib-v* ]]; then
            # Extract version from lib-v* tag
            VERSION="${GITHUB_REF#refs/tags/lib-v}"
            TAG_NAME="${GITHUB_REF#refs/tags/}"
          else
            # Use main version input for lib release
            VERSION="${{ github.event.inputs.version }}"
            TAG_NAME="lib-v${VERSION}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Lib release version: ${VERSION}"
          echo "ðŸ·ï¸ Lib tag: ${TAG_NAME}"

      - name: Validate version format
        run: |
          VERSION="${{ steps.lib_version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected: X.Y.Z or X.Y.Z-suffix (e.g., 1.0.0, 2.1.0-beta)"
            exit 1
          fi
          echo "âœ… Lib version format valid: $VERSION"

      - name: Build lib-only tarball
        run: |
          VERSION="${{ steps.lib_version.outputs.version }}"
          LIB_NAME="dev-control-lib-${VERSION}"
          LIB_DIR="dist/${LIB_NAME}"
          
          mkdir -p "$LIB_DIR"
          
          echo "ðŸ“¦ Building lib-only package: ${LIB_NAME}"
          
          # Copy library files (flatten structure for easy sourcing)
          cp scripts/lib/colors.sh "$LIB_DIR/"
          cp scripts/lib/print.sh "$LIB_DIR/"
          cp scripts/lib/tui.sh "$LIB_DIR/"
          cp scripts/lib/output.sh "$LIB_DIR/"
          cp scripts/lib/validation.sh "$LIB_DIR/"
          cp scripts/lib/cli.sh "$LIB_DIR/"
          cp scripts/lib/version.sh "$LIB_DIR/"
          cp scripts/lib/README.md "$LIB_DIR/"
          
          # Copy config files (if tui theming needed)
          mkdir -p "$LIB_DIR/config"
          cp config/theme.yaml "$LIB_DIR/config/" 2>/dev/null || true
          
          # Copy LICENSE
          cp LICENSE "$LIB_DIR/"
          
          # Create quick-start README
          cat > "$LIB_DIR/INSTALL.md" << 'LIBEOF'
          # Dev-Control Library - Quick Start
          
          This is a lightweight standalone library package containing shared Bash utilities
          for TUI, terminal formatting, colours, and validation.
          
          ## Installation
          
          Extract the tarball to your preferred location:
          
          ```bash
          tar xzf dev-control-lib-*.tar.gz -C /usr/local/share/
          # Or to a local directory
          tar xzf dev-control-lib-*.tar.gz -C ~/.local/share/
          ```
          
          ## Usage
          
          In your Bash scripts:
          
          ```bash
          #!/usr/bin/env bash
          
          # Set your lib path
          DC_LIB="/usr/local/share/dev-control-lib"
          
          # Source the libraries you need
          source "$DC_LIB/colors.sh"
          source "$DC_LIB/print.sh"
          
          # Now use them!
          print_header "My Script"
          print_info "Starting..."
          print_success "Done!"
          ```
          
          ## Available Libraries
          
          | Library | Description |
          |---------|-------------|
          | colors.sh | ANSI colour codes (RED, GREEN, BOLD, etc.) |
          | print.sh | Print functions (print_header, print_info, print_error, etc.) |
          | tui.sh | TUI helpers with Gum integration (optional gum dependency) |
          | output.sh | Output formatting (JSON, quiet, verbose modes) |
          | validation.sh | Input validation (require_var, is_valid_slug, etc.) |
          | cli.sh | CLI argument parsing helpers |
          | version.sh | Semantic version comparison utilities |
          
          See README.md for full documentation.
          LIBEOF
          
          # Create version file
          echo "${VERSION}" > "$LIB_DIR/VERSION"
          
          # Create tarball
          cd dist
          tar czf "${LIB_NAME}.tar.gz" "${LIB_NAME}"
          sha256sum "${LIB_NAME}.tar.gz" > "${LIB_NAME}.tar.gz.sha256"
          cd ..
          
          echo "âœ… Lib tarball built: dist/${LIB_NAME}.tar.gz"
          ls -la dist/

      - name: Set artifact info
        run: |
          VERSION="${{ steps.lib_version.outputs.version }}"
          LIB_TARBALL="dist/dev-control-lib-${VERSION}.tar.gz"
          
          echo "lib_tarball_path=${LIB_TARBALL}" >> $GITHUB_ENV
          echo "lib_tarball_name=dev-control-lib-${VERSION}.tar.gz" >> $GITHUB_ENV
          
          if [[ -f "${LIB_TARBALL}.sha256" ]]; then
            LIB_SHA256=$(cat "${LIB_TARBALL}.sha256" | awk '{print $1}')
            echo "lib_tarball_sha256=${LIB_SHA256}" >> $GITHUB_ENV
            echo "ðŸ” Lib SHA256: ${LIB_SHA256}"
          fi

      - name: Generate lib release notes
        id: lib_release_notes
        run: |
          VERSION="${{ steps.lib_version.outputs.version }}"
          TAG_NAME="${{ steps.lib_version.outputs.tag_name }}"
          
          NOTES_FILE=$(mktemp)
          
          cat > "$NOTES_FILE" << EOF
          ## Dev-Control Library v${VERSION}
          
          Lightweight standalone Bash library for TUI, terminal formatting, and utilities.
          
          **This package contains ONLY the shared libraries** - no CLI, git integration, or plugins.
          Perfect for projects that want consistent terminal output without the full dev-control toolkit.
          
          ## Quick Install
          
          \`\`\`bash
          # Download and extract
          curl -fsSL https://github.com/$GITHUB_REPOSITORY/releases/download/${TAG_NAME}/${lib_tarball_name} | tar xz
          
          # Use in your scripts
          source "./dev-control-lib-${VERSION}/colors.sh"
          source "./dev-control-lib-${VERSION}/print.sh"
          
          print_header "My Script"
          print_success "Ready to go!"
          \`\`\`
          
          ## What's Included
          
          | Library | Description |
          |---------|-------------|
          | \`colors.sh\` | ANSI colour codes (RED, GREEN, BOLD, etc.) |
          | \`print.sh\` | Print functions (print_header, print_info, print_error, etc.) |
          | \`tui.sh\` | TUI helpers with optional Gum integration |
          | \`output.sh\` | Output formatting (JSON, quiet, verbose modes) |
          | \`validation.sh\` | Input validation helpers |
          | \`cli.sh\` | CLI argument parsing utilities |
          | \`version.sh\` | Semantic version comparison |
          
          ## Dependencies
          
          - **Required:** Bash 4.0+
          - **Optional:** [Gum](https://github.com/charmbracelet/gum) for enhanced TUI features
          
          ## Checksums
          
          | File | SHA256 |
          |------|--------|
          | ${lib_tarball_name} | \`${lib_tarball_sha256}\` |
          
          ---
          
          **Full dev-control release:** See [v${VERSION}](https://github.com/$GITHUB_REPOSITORY/releases/tag/v${VERSION}) for the complete toolkit.
          EOF
          
          echo "notes_file=${NOTES_FILE}" >> $GITHUB_OUTPUT
          echo "ðŸ“ Lib release notes generated"

      - name: Create lib tag (manual dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG_NAME="${{ steps.lib_version.outputs.tag_name }}"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $TAG_NAME already exists, skipping tag creation"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG_NAME" -m "Library release $TAG_NAME"
            git push origin "$TAG_NAME"
            echo "âœ… Created and pushed lib tag: $TAG_NAME"
          fi

      - name: Create GitHub Release for lib
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.lib_version.outputs.tag_name }}
          name: "Dev-Control Library ${{ steps.lib_version.outputs.tag_name }}"
          body_path: ${{ steps.lib_release_notes.outputs.notes_file }}
          draft: ${{ github.event.inputs.draft || false }}
          prerelease: ${{ github.event.inputs.prerelease || false }}
          files: |
            dist/dev-control-lib-*.tar.gz
            dist/dev-control-lib-*.sha256
          fail_on_unmatched_files: false
          generate_release_notes: false

      - name: Update 'lib-latest' tag
        run: |
          TAG_NAME="${{ steps.lib_version.outputs.tag_name }}"
          
          # Delete existing 'lib-latest' tag (local and remote)
          git tag -d lib-latest 2>/dev/null || true
          git push origin :refs/tags/lib-latest 2>/dev/null || true
          
          # Create new 'lib-latest' tag pointing to this release
          git tag lib-latest "$TAG_NAME"
          git push origin lib-latest
          
          echo "âœ… Updated 'lib-latest' tag to point to ${TAG_NAME}"

      - name: Lib Release Summary
        run: |
          VERSION="${{ steps.lib_version.outputs.version }}"
          TAG_NAME="${{ steps.lib_version.outputs.tag_name }}"
          
          echo "## ðŸ“š Library Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${VERSION} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | ${TAG_NAME} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tarball | ${lib_tarball_name} |" >> $GITHUB_STEP_SUMMARY
          echo "| SHA256 | \`${lib_tarball_sha256:0:16}...\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Lib Release](https://github.com/$GITHUB_REPOSITORY/releases/tag/${TAG_NAME})" >> $GITHUB_STEP_SUMMARY
          echo "- [Download](https://github.com/$GITHUB_REPOSITORY/releases/download/${TAG_NAME}/${lib_tarball_name})" >> $GITHUB_STEP_SUMMARY
